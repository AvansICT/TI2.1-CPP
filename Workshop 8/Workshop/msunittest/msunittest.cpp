#include "pch.h"                     // auto-generated by Visual Studio
#include <iostream>
#include "CppUnitTest.h"
#include "mymath.hpp"
#include "log.hpp"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;
using namespace myMath;

namespace MSUnitTestMyApp
{
    TEST_CLASS(LibFunctionTests)
    {
    public:
        TEST_METHOD(LogOperatingSystemTest)
        {
            std::stringstream buffer;
            std::streambuf* oldCout = std::cout.rdbuf(buffer.rdbuf());

            LogOperatingSystem();

            std::cout.rdbuf(oldCout); // restore

            std::string output = buffer.str();

#if defined(_WIN32) && defined(_WIN64)
            Assert::IsTrue(output.find("Windows 64-bit") != std::string::npos);
#elif defined(_WIN32)
            Assert::IsTrue(output.find("Windows 32-bit") != std::string::npos);
#elif defined(__APPLE__) || defined(__MACH__)
            Assert::IsTrue(output.find("macOS") != std::string::npos);
#elif defined(__linux__)
            Assert::IsTrue(output.find("Linux") != std::string::npos);
#elif defined(__unix__)
            Assert::IsTrue(output.find("Unix") != std::string::npos);
#elif defined(_POSIX_VERSION)
            Assert::IsTrue(output.find("POSIX-compliant OS") != std::string::npos);
#else
            Assert::IsTrue(output.find("Unknown OS") != std::string::npos);
#endif
        }

        TEST_METHOD(LogCompilerTest)
        {
            std::stringstream buffer;
            std::streambuf* oldCout = std::cout.rdbuf(buffer.rdbuf());

            LogCompiler();

            std::cout.rdbuf(oldCout); // restore
            std::string output = buffer.str();

#if defined(__clang__)
            Assert::IsTrue(output.find("Clang version") != std::string::npos, L"Expected Clang output");
#elif defined(__GNUC__) || defined(__GNUG__)
            Assert::IsTrue(output.find("GCC version") != std::string::npos, L"Expected GCC output");
#elif defined(_MSC_FULL_VER)
            Assert::IsTrue(output.find("MSVC version") != std::string::npos, L"Expected MSVC output");
#else
            Assert::IsTrue(output.find("Unknown compiler") != std::string::npos, L"Expected 'Unknown compiler' output");
#endif
        }

        TEST_METHOD(LogCxxStandardTest)
        {
            std::stringstream buffer;
            std::streambuf* oldCout = std::cout.rdbuf(buffer.rdbuf());

            LogCxxStandard();

            std::cout.rdbuf(oldCout); // restore
            std::string output = buffer.str();

#if __cplusplus >= 202400L
            Assert::IsTrue(output.find("post C++23") != std::string::npos);
#elif __cplusplus == 202302L
            Assert::IsTrue(output.find("C++23") != std::string::npos);
#elif __cplusplus == 202002L
            Assert::IsTrue(output.find("C++20") != std::string::npos);
#elif __cplusplus == 201703L
            Assert::IsTrue(output.find("C++17") != std::string::npos);
#elif __cplusplus == 201402L
            Assert::IsTrue(output.find("C++14") != std::string::npos);
#elif __cplusplus == 201103L
            Assert::IsTrue(output.find("C++11") != std::string::npos);
#else
            Assert::IsTrue(output.find("pre C++11") != std::string::npos);
#endif

            // Optional: check numeric value
            Assert::IsTrue(output.find(std::to_string(__cplusplus)) != std::string::npos);
        }
    };

    TEST_CLASS(MyAppFreeFunctionTests)
    {
    public:
        TEST_METHOD(Add_PositiveNumbers)
        {
            Assert::AreEqual(5, add(2, 3));
        }

        TEST_METHOD(Add_NegativeNumbers)
        {
            Assert::AreEqual(-5, add(-2, -3));
        }

        TEST_METHOD(Add_WithZero)
        {
            Assert::AreEqual(10, add(10, 0));
        }

        TEST_METHOD(Subtract_PositiveNumbers)
        {
            Assert::AreEqual(6, subtract(10, 4));
        }

        TEST_METHOD(Subtract_NegativeNumbers)
        {
            Assert::AreEqual(1, subtract(-2, -3));
        }

        TEST_METHOD(Subtract_WithZero)
        {
            Assert::AreEqual(5, subtract(5, 0));
        }

        TEST_METHOD(Multiply_PositiveNumbers)
        {
            Assert::AreEqual(12, multiply(3, 4));
        }

        TEST_METHOD(Multiply_NegativeNumbers)
        {
            Assert::AreEqual(-12, multiply(-3, 4));
        }

        TEST_METHOD(Multiply_ByZero)
        {
            Assert::AreEqual(0, multiply(7, 0));
        }

        TEST_METHOD(Divide_ValidNumbers)
        {
            Assert::AreEqual(4, divide(8, 2));
        }

        TEST_METHOD(Divide_NegativeNumbers)
        {
            Assert::AreEqual(-2, divide(-10, 5));
        }

        TEST_METHOD(Divide_ByZero_Throws)
        {
            auto func = []() { divide(5, 0); };
            Assert::ExpectException<std::invalid_argument>(func);
        }

        TEST_METHOD(Modulus_ValidNumbers)
        {
            Assert::AreEqual(1, modulus(10, 3));
        }

        TEST_METHOD(Modulus_NegativeNumbers)
        {
            Assert::AreEqual(-1, modulus(-10, 3));
        }

        TEST_METHOD(Modulus_ByZero_Throws)
        {
            auto func = []() { modulus(10, 0); };
            Assert::ExpectException<std::invalid_argument>(func);
        }
    };


    TEST_CLASS(MyAppClassMethodTests)
    {
    public:
        MathFunctions math; // instance shared per test

        TEST_METHOD(Add_UsingClass)
        {
            Assert::AreEqual(10, math.add(5, 5));
        }

        TEST_METHOD(Subtract_UsingClass)
        {
            Assert::AreEqual(2, math.subtract(10, 8));
        }

        TEST_METHOD(Multiply_UsingClass)
        {
            Assert::AreEqual(15, math.multiply(3, 5));
        }

        TEST_METHOD(Divide_UsingClass)
        {
            Assert::AreEqual(3, math.divide(9, 3));
        }

        TEST_METHOD(Divide_ByZero_UsingClass_Throws)
        {
            auto func = [&]() { math.divide(1, 0); };
            Assert::ExpectException<std::invalid_argument>(func);
        }

        TEST_METHOD(Modulus_UsingClass)
        {
            Assert::AreEqual(1, math.modulus(10, 3));
        }

        TEST_METHOD(Modulus_ByZero_UsingClass_Throws)
        {
            auto func = [&]() { math.modulus(10, 0); };
            Assert::ExpectException<std::invalid_argument>(func);
        }
    };
}
